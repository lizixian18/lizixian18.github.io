<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo 博客操作</title>
      <link href="/2019/02/28/Hexo%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/02/28/Hexo%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>cd 到 hexo 的目录</p><a id="more"></a><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>写文章</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>执行 hexo g 生成静态文件</p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>执行 hexo clean &amp;&amp; hexo deploy 部署到 Github</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 代码实践</title>
      <link href="/2019/02/28/Kotlin%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/02/28/Kotlin%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><p>让 start() 方法返回字符串 “OK”  </p><a id="more"></a><p>答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun start():String = &quot;OK&quot;</span><br></pre></td></tr></table></figure></p><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>函数 joinToString 使用参数的默认声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//String 扩展函数</span><br><span class="line">fun joinToString(</span><br><span class="line">    separator: String = &quot;, &quot;,</span><br><span class="line">    prefix: String = &quot;&quot;,</span><br><span class="line">    postfix: String = &quot;&quot;,</span><br><span class="line">    /* ... */</span><br><span class="line">): String</span><br></pre></td></tr></table></figure></p><p>它可以在一系列字符串上调用。 仅指定两个参数使函数 joinOptions（）以JSON格式返回列表（例如，“[a，b，c]”）  </p><p>答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun joinOptions(option:Collection&lt;String&gt;) = option.joinToString(prefix=&quot;[&quot;,postfix=&quot;]&quot;)</span><br></pre></td></tr></table></figure></p><p>##默认参数<br>Java 中有几个 foo() 函数的重载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String foo(String name, int number, boolean toUpperCase) &#123;</span><br><span class="line">    return (toUpperCase ? name.toUpperCase() : name) + number;</span><br><span class="line">&#125;</span><br><span class="line">public String foo(String name, int number) &#123;</span><br><span class="line">    return foo(name, number, false);</span><br><span class="line">&#125;</span><br><span class="line">public String foo(String name, boolean toUpperCase) &#123;</span><br><span class="line">    return foo(name, 42, toUpperCase);</span><br><span class="line">&#125;</span><br><span class="line">public String foo(String name) &#123;</span><br><span class="line">    return foo(name, 42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有这些Java重载都可以用Kotlin中的一个函数替换。 以使用foo编译的代码的方式更改函数foo的声明。 使用默认和命名参数。</p><p>答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun foo(name:String,number:Int = 42,toUpperCase:Boolean = false) = </span><br><span class="line">    if((toUpperCase)name.toUpperCase() else name)+number</span><br><span class="line"></span><br><span class="line">fun useFoo() = listOf(</span><br><span class="line">    foo(&quot;a&quot;),</span><br><span class="line">    foo(&quot;b&quot;,number = 1),</span><br><span class="line">    foo(&quot;c&quot;,toUpperCase = true),</span><br><span class="line">    foo(name = &quot;d&quot;,number = 2,toUpperCase = true)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>将lambda传递给任何函数以检查集合是否包含偶数。 函数any将谓词作为参数获取，如果至少有一个元素满足谓词，则返回true。</p><p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun containsEven(collection:Collection&lt;Int&gt;):Boolean = collection.any&#123;</span><br><span class="line">    it % 2 ==0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>将以下Java代码重写为Kotlin：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name:String,val age:Int)</span><br><span class="line"></span><br><span class="line">fun getPeople():List&lt;Person&gt;&#123;</span><br><span class="line">    return listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>阅读Kotlin中的null安全和安全调用，并仅使用一个if表达式重写以下Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void sendMessageToClient(</span><br><span class="line">    @Nullable Client client,</span><br><span class="line">    @Nullable String message,</span><br><span class="line">    @NotNull Mailer mailer</span><br><span class="line">) &#123;</span><br><span class="line">    if (client == null || message == null) return;</span><br><span class="line"></span><br><span class="line">    PersonalInfo personalInfo = client.getPersonalInfo();</span><br><span class="line">    if (personalInfo == null) return;</span><br><span class="line"></span><br><span class="line">    String email = personalInfo.getEmail();</span><br><span class="line">    if (email == null) return;</span><br><span class="line"></span><br><span class="line">    mailer.sendMessage(email, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun sendMessageToClient(client:Client?,message:String?,mailer:Mailer)&#123;</span><br><span class="line">    val email = client?.personalInfo?.email</span><br><span class="line">    if(email!=null&amp;&amp;message!=null)&#123;</span><br><span class="line">        mailer.sendMessage(email,message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client(val personalInfo:PersonalInfo?)</span><br><span class="line">class PersonalInfo(val email:String?)</span><br><span class="line">interface Mailer&#123;</span><br><span class="line">    fun sendMessage(email:String,message:String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Smart-casts"><a href="#Smart-casts" class="headerlink" title="Smart casts"></a>Smart casts</h2><p>使用智能转换和表达式重写以下Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int eval(Expr expr) &#123;</span><br><span class="line">    if (expr instanceof Num) &#123;</span><br><span class="line">        return ((Num) expr).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    if (expr instanceof Sum) &#123;</span><br><span class="line">        Sum sum = (Sum) expr;</span><br><span class="line">        return eval(sum.getLeft()) + eval(sum.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Unknown expression&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun eval(expr):Int = </span><br><span class="line">    when(expr)&#123;</span><br><span class="line">        is Num -&gt; expr.value</span><br><span class="line">        is Sum -&gt; eval(expr.left)+eval(expr.right)</span><br><span class="line">        else -&gt; throw IllegalArgumentException(&quot;Unknown expression&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 类</title>
      <link href="/2019/02/28/Kotlin%20%E7%B1%BB/"/>
      <url>/2019/02/28/Kotlin%20%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。  </p><a id="more"></a><h3 id="主构造函数："><a href="#主构造函数：" class="headerlink" title="主构造函数："></a>主构造函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(firstName: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p> 主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。</p><p> 在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class InitOrderDemo(name: String) &#123;</span><br><span class="line">    val firstProperty = &quot;First property: $name&quot;.also(::println)</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;First initializer block that prints $&#123;name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    val secondProperty = &quot;Second property: $&#123;name.length&#125;&quot;.also(::println)</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;Second initializer block that prints $&#123;name.length&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p> 类也可以声明前缀有 constructor 的次构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(parent: Person) &#123;</span><br><span class="line">        parent.children.add(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;</span><br><span class="line">    constructor(name: String, parent: Person) : this(name) &#123;</span><br><span class="line">        parent.children.add(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Constructors &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;Init block&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(i: Int) &#123;</span><br><span class="line">        println(&quot;Constructor&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>Init block<br>Constructor</p><h2 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val invoice = Invoice()</span><br><span class="line"></span><br><span class="line">val customer = Customer(&quot;Joe Smith&quot;)</span><br></pre></td></tr></table></figure><p>注意 Kotlin 并没有 new 关键字。</p><h2 id="嵌套类与内部类"><a href="#嵌套类与内部类" class="headerlink" title="嵌套类与内部类"></a>嵌套类与内部类</h2><p>类可以嵌套在其他类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    class Nested &#123;</span><br><span class="line">        fun foo() = 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val demo = Outer.Nested().foo() // == 2</span><br></pre></td></tr></table></figure></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类可以标记为 inner 以便能够访问外部类的成员。内部类会带有一个对外部类的对象的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    inner class Inner &#123;</span><br><span class="line">        fun foo() = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val demo = Outer().Inner().foo() // == 1</span><br></pre></td></tr></table></figure></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式创建匿名内部类实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(object : MouseAdapter() &#123;</span><br><span class="line"></span><br><span class="line">    override fun mouseClicked(e: MouseEvent) &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">    override fun mouseEntered(e: MouseEvent) &#123; …… &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Kotlin 中所有类都有一个共同的超类 Any<br>要声明一个显式的超类型，我们把类型放到类头的冒号之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class Base(p: Int)</span><br><span class="line"></span><br><span class="line">class Derived(p: Int) : Base(p)</span><br></pre></td></tr></table></figure></p><p>如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。</p><p>如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyView : View &#123;</span><br><span class="line">    constructor(ctx: Context) : super(ctx)</span><br><span class="line"></span><br><span class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun v() &#123; ... &#125;</span><br><span class="line">    fun nv() &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived() : Base() &#123;</span><br><span class="line">    override fun v() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Derived.v() 函数上必须加上 override 修饰符。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，那么子类中不允许定义相同签名的函数， 不论加不加 override。将 open 修饰符添加到 final 类（即没有 open 的类）的成员上不起作用。</p><p>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class AnotherDerived() : Base() &#123;</span><br><span class="line">    final override fun v() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h2><p>属性覆盖与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;</span><br><span class="line">    open val x: Int get() &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1 : Foo() &#123;</span><br><span class="line">    override val x: Int = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。这是允许的，因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法。</p><h2 id="派生类初始化顺序"><a href="#派生类初始化顺序" class="headerlink" title="派生类初始化顺序"></a>派生类初始化顺序</h2><p>在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">open class Base(val name: String) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123; println(&quot;Initializing Base&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    open val size: Int = </span><br><span class="line">        name.length.also &#123; println(&quot;Initializing size in Base: $it&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Derived(</span><br><span class="line">    name: String,</span><br><span class="line">    val lastName: String</span><br><span class="line">) : Base(name.capitalize().also &#123; println(&quot;Argument for Base: $it&quot;) &#125;) &#123; </span><br><span class="line"></span><br><span class="line">    init &#123; println(&quot;Initializing Derived&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    override val size: Int =</span><br><span class="line">        (super.size + lastName.length).also &#123; println(&quot;Initializing size in Derived: $it&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Constructing Derived(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">Argument for Base: Hello</span><br><span class="line">Initializing Base</span><br><span class="line">Initializing size in Base: 5</span><br><span class="line">Initializing Derived</span><br><span class="line">Initializing size in Derived: 10</span><br></pre></td></tr></table></figure></p><p>这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 基础</title>
      <link href="/2019/02/28/Kotlin%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/02/28/Kotlin%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>带有两个 Int 参数、返回 Int 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a Int,b:Int):Int&#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>将表达式作为函数体、返回值类型自动推断的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int,b:Int) = a+b</span><br></pre></td></tr></table></figure></p><p>函数默认参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun foo(a: Int = 0, b: String = &quot;&quot;) &#123; …… &#125;</span><br></pre></td></tr></table></figure></p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义只读局部变量使用关键字 val 定义。只能为其赋值一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a: Int = 1  // 立即赋值</span><br><span class="line">val b = 2   // 自动推断出 `Int` 类型</span><br><span class="line">val c: Int  // 如果没有初始值类型不能省略</span><br><span class="line">c = 3       // 明确赋值</span><br></pre></td></tr></table></figure></p><p>可重新赋值的变量使用 var 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = 5 // 自动推断出 `Int` 类型</span><br><span class="line">x += 1</span><br></pre></td></tr></table></figure></p><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun maxOf(a: Int, b: Int): Int &#123;</span><br><span class="line">    if (a &gt; b) &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 if 作为表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun maxOf(a:Int,b:Int) = if(a&gt;b) a else b</span><br></pre></td></tr></table></figure></p><h2 id="使用可空值及-null-检测"><a href="#使用可空值及-null-检测" class="headerlink" title="使用可空值及 null 检测"></a>使用可空值及 null 检测</h2><p>某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。<br>如果 str 的内容不是数字返回 null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="If-not-null-缩写"><a href="#If-not-null-缩写" class="headerlink" title="If not null 缩写"></a>If not null 缩写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val files = File(&quot;Test&quot;).listFiles()</span><br><span class="line"></span><br><span class="line">println(files?.size)</span><br></pre></td></tr></table></figure><h2 id="If-not-null-and-else-缩写"><a href="#If-not-null-and-else-缩写" class="headerlink" title="If not null and else 缩写"></a>If not null and else 缩写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val files = File(&quot;Test&quot;).listFiles()</span><br><span class="line"></span><br><span class="line">println(files?.size ?: &quot;empty&quot;)</span><br></pre></td></tr></table></figure><h2 id="if-null-执行一个语句"><a href="#if-null-执行一个语句" class="headerlink" title="if null 执行一个语句"></a>if null 执行一个语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val values = ……</span><br><span class="line">val email = values[&quot;email&quot;] ?: throw IllegalStateException(&quot;Email is missing!&quot;)</span><br></pre></td></tr></table></figure><h2 id="在可能会空的集合中取第一元素"><a href="#在可能会空的集合中取第一元素" class="headerlink" title="在可能会空的集合中取第一元素"></a>在可能会空的集合中取第一元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val emails = …… // 可能会是空集合</span><br><span class="line">val mainEmail = emails.firstOrNull() ?: &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="if-not-null-执行代码"><a href="#if-not-null-执行代码" class="headerlink" title="if not null 执行代码"></a>if not null 执行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val value = ……</span><br><span class="line"></span><br><span class="line">value?.let &#123;</span><br><span class="line">    …… // 代码会执行到此处, 假如data不为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射可空值（如果非空的话"><a href="#映射可空值（如果非空的话" class="headerlink" title="映射可空值（如果非空的话"></a>映射可空值（如果非空的话</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val value = ……</span><br><span class="line"></span><br><span class="line">val mapped = value?.let &#123; transformValue(it) &#125; ?: defaultValueIfValueIsNull</span><br></pre></td></tr></table></figure><h2 id="使用类型检测及自动类型转换"><a href="#使用类型检测及自动类型转换" class="headerlink" title="使用类型检测及自动类型转换"></a>使用类型检测及自动类型转换</h2><p>is 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // `obj` 在该条件分支内自动转换成 `String`</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>is 前面可以加感叹号即为相反意思 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj !is String) return null</span><br><span class="line">    // `obj` 在这一分支自动转换为 `String`</span><br><span class="line">    return obj.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>简单的创建一个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="for-循环："><a href="#for-循环：" class="headerlink" title="for 循环："></a>for 循环：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">var index = 0</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when-表达式（取代了switch）"><a href="#when-表达式（取代了switch）" class="headerlink" title="when 表达式（取代了switch）"></a>when 表达式（取代了switch）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">    when (obj) &#123;</span><br><span class="line">        1          -&gt; &quot;One&quot;</span><br><span class="line">        &quot;Hello&quot;    -&gt; &quot;Greeting&quot;</span><br><span class="line">        is Long    -&gt; &quot;Long&quot;</span><br><span class="line">        !is String -&gt; &quot;Not a string&quot;</span><br><span class="line">        in 1..10 -&gt; print(&quot;x is in the range&quot;)</span><br><span class="line">        x.isOdd() -&gt; print(&quot;x is odd&quot;)</span><br><span class="line">        else       -&gt; &quot;Unknown&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用区间（range）"><a href="#使用区间（range）" class="headerlink" title="使用区间（range）"></a>使用区间（range）</h3><p>使用 in 运算符来检测某个数字是否在指定区间内(区间外用 !in )：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val x = 10</span><br><span class="line">val y = 9</span><br><span class="line">if (x in 1..y+1) &#123;</span><br><span class="line">    println(&quot;fits in range&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区间迭代:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (x in 1..5) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数列迭代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (x in 1..10 step 2) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">for (x in 9 downTo 0 step 3) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br>13579<br>9630</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..100) &#123; …… &#125;  // 闭区间：包含 100</span><br><span class="line">for (i in 1 until 100) &#123; …… &#125; // 半开区间：不包含 100</span><br><span class="line">for (x in 2..10 step 2) &#123; …… &#125;</span><br><span class="line">for (x in 10 downTo 1) &#123; …… &#125;</span><br><span class="line">if (x in 1..10) &#123; …… &#125;</span><br></pre></td></tr></table></figure><h3 id="使用-lambda-表达式来过滤（filter）与映射（map）集合："><a href="#使用-lambda-表达式来过滤（filter）与映射（map）集合：" class="headerlink" title="使用 lambda 表达式来过滤（filter）与映射（map）集合："></a>使用 lambda 表达式来过滤（filter）与映射（map）集合：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val fruits = listOf(&quot;banana&quot;, &quot;avocado&quot;, &quot;apple&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">fruits</span><br><span class="line">  .filter &#123; it.startsWith(&quot;a&quot;) &#125;</span><br><span class="line">  .sortedBy &#123; it &#125;</span><br><span class="line">  .map &#123; it.toUpperCase() &#125;</span><br><span class="line">  .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>输出：<br>APPLE<br>AVOCADO</p><h3 id="遍历-map-pair型list"><a href="#遍历-map-pair型list" class="headerlink" title="遍历 map/pair型list"></a>遍历 map/pair型list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for((k,v) in map)&#123;</span><br><span class="line">    println(&quot;$k -&gt; $v&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-map"><a href="#访问-map" class="headerlink" title="访问 map"></a>访问 map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(map[&quot;key&quot;])</span><br><span class="line">map[&quot;key&quot;] = value</span><br></pre></td></tr></table></figure><h2 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val p:String by lazy&#123;</span><br><span class="line">    //计算该字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun String.spaceToCamelCase() &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">&quot;Convert this to camelcase&quot;.spaceToCamelCase()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列的实现</title>
      <link href="/2019/02/28/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/28/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>个人觉得队列的使用在项目开发中挺多地方可以用到的，所以将如何封装一个队列的过程记录下来，总体来说难度并不大，但毕竟能力有限，如果各位有好的建议或意见欢迎提出来，如果本文能帮到你的话，记得点赞哦。</p> <a id="more"></a><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>在项目开发中，会经常遇到一些需要排队执行的功能，比如发动态时上传多张图片，需要一张一张的上传，比如直播间动画连需发送或者收到消息需要展示时，需要一个一个动画去展示等等场景，这时候会容易想到用队列去实现，但是我想不少小伙伴会直接弄一个 list，存着要执行的任务，然后通过递归的方式去遍历列表实现，类似下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//存着一些执行任务的列表</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//执行任务</span><br><span class="line">private void doTask() &#123;</span><br><span class="line">    if (list.size() &gt; 0) &#123;</span><br><span class="line">        String task = list.get(0);</span><br><span class="line">        doSoming(task);</span><br><span class="line">        list.remove(0);</span><br><span class="line">        doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先这种方式实现是可以完成所需要的功能的，面对一些简单的场景来说比较容易想到而且实现也简单。但是面对复杂一点的场景却有着不少缺点，特别是在一些祖传项目里面，谁也说不准代码有多乱，到时候维护是很困难的（这个本人已在实际项目中深有体会）。所以封装一个队列去完成这种功能，是一个比较实用而且必须的手段。</p><h3 id="首先看看要封装的队列需要有什么功能："><a href="#首先看看要封装的队列需要有什么功能：" class="headerlink" title="首先看看要封装的队列需要有什么功能："></a>首先看看要封装的队列需要有什么功能：</h3><ol><li>在实际中，我们执行的任务大概可以分两种，一个是有明确的执行时间的，比如，要连续显示10个动画，每个展示5秒这种。一个是没明确的执行时间的，比如连续上传10张图片，每个上传任务的完成时间是需要等到上传成功回调回来才知道的这种。所以队列第一个功能是每个任务都可以兼容这两种情况，而且当然是一个执行完再执行下一个，排队执行。</li><li>既然要排队执行，当然会有优先级之分，所以每个任务都能设置优先级，队列可以根据优先级去排队执行任务。</li></ol><p>至于队列选哪一个，我这里选择的是 PriorityBlockingQueue（阻塞优先级队列），这个队列的特点是存储的对象必须是实现Comparable接口，而且它是阻塞队列，其他特点或者不了解的同学可以自行去了解，接下来都是对它的封装。</p><h3 id="1-定义一个枚举类TaskPriority，定义任务的优先级。"><a href="#1-定义一个枚举类TaskPriority，定义任务的优先级。" class="headerlink" title="1. 定义一个枚举类TaskPriority，定义任务的优先级。"></a>1. 定义一个枚举类TaskPriority，定义任务的优先级。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum TaskPriority &#123;</span><br><span class="line">    LOW, //低</span><br><span class="line">    DEFAULT,//普通</span><br><span class="line">    HIGH, //高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级分为3种，如注释所示，他们的关系：LOW&lt;DEFAULT&lt;HIGH</p><h3 id="2-队列任务执行时间确定和不确定两种情况的实现策略"><a href="#2-队列任务执行时间确定和不确定两种情况的实现策略" class="headerlink" title="2.队列任务执行时间确定和不确定两种情况的实现策略"></a>2.队列任务执行时间确定和不确定两种情况的实现策略</h3><ol><li>针对任务执行时间确定的这种情况，比较简单，可以给这个任务设置一个时间 duration，等任务开始执行时，便开始阻塞等待，等到时间到达时，才放开执行下一个任务。</li><li>针对任务执行时间不确定的情况，我们则需要在任务执行完成的回调里面手动放开，所以这里打算再用一个PriorityBlockingQueue队列，因为它有这样的一个特点：<strong>如果队列是空的，调用它的 take()方法时，它就会一直阻塞在那里，当列表不为空时，这个方法就不会阻塞。</strong> 所以当任务开始执行时，调用take()方法，等到我们的完成回调来时，再手动给它add一个值，阻塞就放开，再执行下一个任务。</li></ol><h3 id="3-确定了任务两种情况的实现策略后，接下来定义一个接口，定义一下每个任务需要做什么事情"><a href="#3-确定了任务两种情况的实现策略后，接下来定义一个接口，定义一下每个任务需要做什么事情" class="headerlink" title="3.确定了任务两种情况的实现策略后，接下来定义一个接口，定义一下每个任务需要做什么事情"></a>3.确定了任务两种情况的实现策略后，接下来定义一个接口，定义一下每个任务需要做什么事情</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public interface ITask extends Comparable&lt;ITask&gt; &#123;</span><br><span class="line">    //将该任务插入队列</span><br><span class="line">    void enqueue();</span><br><span class="line"></span><br><span class="line">    //执行具体任务的方法</span><br><span class="line">    void doTask();</span><br><span class="line"></span><br><span class="line">    //任务执行完成后的回调方法</span><br><span class="line">    void finishTask();</span><br><span class="line"></span><br><span class="line">    //设置任务优先级</span><br><span class="line">    ITask setPriority(TaskPriority mTaskPriority);</span><br><span class="line"></span><br><span class="line">    //获取任务优先级</span><br><span class="line">    TaskPriority getPriority();</span><br><span class="line"></span><br><span class="line">    //当优先级相同 按照插入顺序 先入先出 该方法用来标记插入顺序</span><br><span class="line">    void setSequence(int mSequence);</span><br><span class="line"></span><br><span class="line">    //获取入队次序</span><br><span class="line">    int getSequence();</span><br><span class="line"></span><br><span class="line">    //每个任务的状态，就是标记完成和未完成</span><br><span class="line">    boolean getStatus();</span><br><span class="line">    </span><br><span class="line">    //设置每个任务的执行时间，该方法用于任务执行时间确定的情况</span><br><span class="line">    ITask setDuration(int duration);</span><br><span class="line">    </span><br><span class="line">    //获取每个任务执行的时间</span><br><span class="line">    int getDuration();</span><br><span class="line"></span><br><span class="line">    //阻塞任务执行，该方法用于任务执行时间不确定的情况</span><br><span class="line">    void blockTask() throws Exception;</span><br><span class="line"></span><br><span class="line">    //解除阻塞任务，该方法用于任务执行时间不确定的情况</span><br><span class="line">    void unLockBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口基本定义了一些基本需要的方法，因为PriorityBlockingQueue的特点，所以接口继承了Comparable，用于实现优先级排队功能。具体方法功能请看注释。</p><h3 id="4-封装一下PriorityBlockingQueue的基本功能"><a href="#4-封装一下PriorityBlockingQueue的基本功能" class="headerlink" title="4.封装一下PriorityBlockingQueue的基本功能"></a>4.封装一下PriorityBlockingQueue的基本功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BlockTaskQueue &#123;</span><br><span class="line">    private String TAG = &quot;BlockTaskQueue&quot;;</span><br><span class="line">    private AtomicInteger mAtomicInteger = new AtomicInteger();</span><br><span class="line">    //阻塞队列</span><br><span class="line">    private final BlockingQueue&lt;ITask&gt; mTaskQueue = new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private BlockTaskQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式</span><br><span class="line">    private static class BlockTaskQueueHolder &#123;</span><br><span class="line">        private final static BlockTaskQueue INSTANCE = new BlockTaskQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BlockTaskQueue getInstance() &#123;</span><br><span class="line">        return BlockTaskQueueHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入时 因为每一个Task都实现了comparable接口 所以队列会按照Task复写的compare()方法定义的优先级次序进行插入</span><br><span class="line">     * 当优先级相同时，使用AtomicInteger原子类自增 来为每一个task 设置sequence，</span><br><span class="line">     * sequence的作用是标记两个相同优先级的任务入队的次序</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends ITask&gt; int add(T task) &#123;</span><br><span class="line">        if (!mTaskQueue.contains(task)) &#123;</span><br><span class="line">            task.setSequence(mAtomicInteger.incrementAndGet());</span><br><span class="line">            mTaskQueue.add(task);</span><br><span class="line">            Log.d(TAG, &quot;\n add task &quot; + task.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return mTaskQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T extends ITask&gt; void remove(T task) &#123;</span><br><span class="line">        if (mTaskQueue.contains(task)) &#123;</span><br><span class="line">            Log.d(TAG, &quot;\n&quot; + &quot;task has been finished. remove it from task queue&quot;);</span><br><span class="line">            mTaskQueue.remove(task);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mTaskQueue.size() == 0) &#123;</span><br><span class="line">            mAtomicInteger.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ITask poll() &#123;</span><br><span class="line">        return mTaskQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ITask take() throws InterruptedException &#123;</span><br><span class="line">        return mTaskQueue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        mTaskQueue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return mTaskQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个简单的封装，具体解释请看注释。</p><h3 id="5-写一个类记录下当前执行的任务信息，方便获取时使用"><a href="#5-写一个类记录下当前执行的任务信息，方便获取时使用" class="headerlink" title="5. 写一个类记录下当前执行的任务信息，方便获取时使用"></a>5. 写一个类记录下当前执行的任务信息，方便获取时使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentRunningTask &#123;</span><br><span class="line">    private static ITask sCurrentShowingTask;</span><br><span class="line"></span><br><span class="line">    public static void setCurrentShowingTask(ITask task) &#123;</span><br><span class="line">        sCurrentShowingTask = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void removeCurrentShowingTask() &#123;</span><br><span class="line">        sCurrentShowingTask = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ITask getCurrentShowingTask() &#123;</span><br><span class="line">        return sCurrentShowingTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean getCurrentShowingStatus() &#123;</span><br><span class="line">        return sCurrentShowingTask != null &amp;&amp; sCurrentShowingTask.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候要获取一些正在执行的任务的信息，所以这里弄类一个类来将正在执行的任务存储起来。</p><h3 id="6-基础需要的东西都写好后，下面开始封装一个基础的任务类了"><a href="#6-基础需要的东西都写好后，下面开始封装一个基础的任务类了" class="headerlink" title="6. 基础需要的东西都写好后，下面开始封装一个基础的任务类了"></a>6. 基础需要的东西都写好后，下面开始封装一个基础的任务类了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class BaseTask implements ITask &#123;</span><br><span class="line">    private final String TAG = getClass().getSimpleName();</span><br><span class="line">    private TaskPriority mTaskPriority = TaskPriority.DEFAULT; //默认优先级</span><br><span class="line">    private int mSequence;// 入队次序</span><br><span class="line">    private Boolean mTaskStatus = false; // 标志任务状态，是否仍在展示</span><br><span class="line">    protected WeakReference&lt;BlockTaskQueue&gt; taskQueue;//阻塞队列</span><br><span class="line">    protected int duration = 0; //任务执行时间</span><br><span class="line">    //此队列用来实现任务时间不确定的队列阻塞功能</span><br><span class="line">    private PriorityBlockingQueue&lt;Integer&gt; blockQueue;</span><br><span class="line">    //构造函数</span><br><span class="line">    public BaseTask() &#123;</span><br><span class="line">        taskQueue = new WeakReference&lt;&gt;(BlockTaskQueue.getInstance());</span><br><span class="line">        blockQueue = new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    //入队实现</span><br><span class="line">    @Override</span><br><span class="line">    public void enqueue() &#123;</span><br><span class="line">        TaskScheduler.getInstance().enqueue(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //执行任务方法，此时标记为设为true，并且将当前任务记录下来</span><br><span class="line">    @Override</span><br><span class="line">    public void doTask() &#123;</span><br><span class="line">        mTaskStatus = true;</span><br><span class="line">        CurrentRunningTask.setCurrentShowingTask(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //任务执行完成，改变标记位，将任务在队列中移除，并且把记录清除</span><br><span class="line">    @Override</span><br><span class="line">    public void finishTask() &#123;</span><br><span class="line">        this.mTaskStatus = false;</span><br><span class="line">        this.taskQueue.get().remove(this);</span><br><span class="line">        CurrentRunningTask.removeCurrentShowingTask();</span><br><span class="line">        Log.d(TAG, taskQueue.get().size() + &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //设置任务优先级实现</span><br><span class="line">    @Override</span><br><span class="line">    public ITask setPriority(TaskPriority mTaskPriority) &#123;</span><br><span class="line">        this.mTaskPriority = mTaskPriority;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置任务执行时间</span><br><span class="line">    public ITask setDuration(int duration) &#123;</span><br><span class="line">        this.duration = duration;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取任务优先级</span><br><span class="line">    @Override</span><br><span class="line">    public TaskPriority getPriority() &#123;</span><br><span class="line">        return mTaskPriority;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取任务执行时间</span><br><span class="line">    @Override</span><br><span class="line">    public int getDuration() &#123;</span><br><span class="line">        return duration;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置任务次序</span><br><span class="line">    @Override</span><br><span class="line">    public void setSequence(int mSequence) &#123;</span><br><span class="line">        this.mSequence = mSequence;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取任务次序</span><br><span class="line">    @Override</span><br><span class="line">    public int getSequence() &#123;</span><br><span class="line">        return mSequence;</span><br><span class="line">    &#125;</span><br><span class="line">    获取任务状态</span><br><span class="line">    @Override</span><br><span class="line">    public boolean getStatus() &#123;</span><br><span class="line">        return mTaskStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    //阻塞任务执行</span><br><span class="line">    @Override</span><br><span class="line">    public void blockTask() throws Exception &#123;</span><br><span class="line">        blockQueue.take(); //如果队列里面没数据，就会一直阻塞</span><br><span class="line">    &#125;</span><br><span class="line">    //解除阻塞</span><br><span class="line">     @Override</span><br><span class="line">     public void unLockBlock() &#123;</span><br><span class="line">        blockQueue.add(1); //往里面随便添加一个数据，阻塞就会解除</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 排队实现</span><br><span class="line">     * 优先级的标准如下：</span><br><span class="line">     * TaskPriority.LOW &lt; TaskPriority.DEFAULT &lt; TaskPriority.HIGH</span><br><span class="line">     * 当优先级相同 按照插入次序排队</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(ITask another) &#123;</span><br><span class="line">        final TaskPriority me = this.getPriority();</span><br><span class="line">        final TaskPriority it = another.getPriority();</span><br><span class="line">        return me == it ? this.getSequence() - another.getSequence() :</span><br><span class="line">                it.ordinal() - me.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line">    //输出一些信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;task name : &quot; + getClass().getSimpleName() + &quot; sequence : &quot; + mSequence + &quot; TaskPriority : &quot; + mTaskPriority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码并不难，看注释应该都会懂，这里看下入队方法，并没有直接 add 到 taskQueue 里面，而且通过 TaskScheduler 的 enqueue 方法入队，TaskScheduler 是一个任务调度类，里面封装了入队以及对队列操作的一些功能，下面看看它是如何实现的。</p><h3 id="7-TaskScheduler"><a href="#7-TaskScheduler" class="headerlink" title="7. TaskScheduler"></a>7. TaskScheduler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class TaskScheduler &#123;</span><br><span class="line">    private final String TAG = &quot;TaskScheduler&quot;;</span><br><span class="line">    private BlockTaskQueue mTaskQueue = BlockTaskQueue.getInstance();</span><br><span class="line">    private ShowTaskExecutor mExecutor;</span><br><span class="line"></span><br><span class="line">    private static class ShowDurationHolder &#123;</span><br><span class="line">        private final static TaskScheduler INSTANCE = new TaskScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TaskScheduler() &#123;</span><br><span class="line">        initExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initExecutor() &#123;</span><br><span class="line">        mExecutor = new ShowTaskExecutor(mTaskQueue);</span><br><span class="line">        mExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static TaskScheduler getInstance() &#123;</span><br><span class="line">        return ShowDurationHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     public void enqueue(ITask task) &#123;</span><br><span class="line">        //因为TaskScheduler这里写成单例，如果isRunning改成false的话，不判断一下，就会一直都是false</span><br><span class="line">        if (!mExecutor.isRunning()) &#123;</span><br><span class="line">            mExecutor.startRunning();</span><br><span class="line">        &#125;</span><br><span class="line">        //按照优先级插入队列 依次播放</span><br><span class="line">        mTaskQueue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void resetExecutor() &#123;</span><br><span class="line">        mExecutor.resetExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clearExecutor() &#123;</span><br><span class="line">        mExecutor.clearExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShowTaskExecutor是一个任务排队执行器，里面主要是一个死循环，不断的在队列里面取出任务，并且执行任务，下面看看它的实现。</p><h3 id="8-ShowTaskExecutor"><a href="#8-ShowTaskExecutor" class="headerlink" title="8.ShowTaskExecutor"></a>8.ShowTaskExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public class ShowTaskExecutor &#123;</span><br><span class="line">    private final String TAG = &quot;ShowTaskExecutor&quot;;</span><br><span class="line">    private BlockTaskQueue taskQueue;</span><br><span class="line">    private TaskHandler mTaskHandler;</span><br><span class="line">    private boolean isRunning = true;</span><br><span class="line">    private static final int MSG_EVENT_DO = 0;</span><br><span class="line">    private static final int MSG_EVENT_FINISH = 1;</span><br><span class="line"></span><br><span class="line">    public ShowTaskExecutor(BlockTaskQueue taskQueue) &#123;</span><br><span class="line">        this.taskQueue = taskQueue;</span><br><span class="line">        mTaskHandler = new TaskHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    //开始遍历任务队列</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    while (isRunning) &#123; //死循环</span><br><span class="line">                        ITask iTask;</span><br><span class="line">                        iTask = taskQueue.take(); //取任务</span><br><span class="line">                        if (iTask != null) &#123;</span><br><span class="line">                            //执行任务</span><br><span class="line">                            TaskEvent doEvent = new TaskEvent();</span><br><span class="line">                            doEvent.setTask(iTask);</span><br><span class="line">                            doEvent.setEventType(TaskEvent.EventType.DO);</span><br><span class="line">                            mTaskHandler.obtainMessage(MSG_EVENT_DO, doEvent).sendToTarget();</span><br><span class="line">                            //一直阻塞，直到任务执行完</span><br><span class="line">                            if (iTask.getDuration()!=0) &#123;</span><br><span class="line">                                TimeUnit.MICROSECONDS.sleep(iTask.getDuration());</span><br><span class="line">                            &#125;else &#123;</span><br><span class="line">                                iTask.blockTask();</span><br><span class="line">                            &#125;</span><br><span class="line">                            //完成任务</span><br><span class="line">                            TaskEvent finishEvent = new TaskEvent();</span><br><span class="line">                            finishEvent.setTask(iTask);</span><br><span class="line">                            finishEvent.setEventType(TaskEvent.EventType.FINISH);</span><br><span class="line">                            mTaskHandler.obtainMessage(MSG_EVENT_FINISH, finishEvent).sendToTarget();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据不同的消息回调不同的方法。</span><br><span class="line">    private static class TaskHandler extends Handler &#123;</span><br><span class="line">        TaskHandler() &#123;</span><br><span class="line">            super(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            TaskEvent taskEvent = (TaskEvent) msg.obj;</span><br><span class="line">            if (msg.what == MSG_EVENT_DO &amp;&amp; taskEvent.getEventType() == TaskEvent.EventType.DO) &#123;</span><br><span class="line">                taskEvent.getTask().doTask();</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg.what == MSG_EVENT_FINISH &amp;&amp; taskEvent.getEventType() == TaskEvent.EventType.FINISH) &#123;</span><br><span class="line">                taskEvent.getTask().finishTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void startRunning() &#123;</span><br><span class="line">        isRunning = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pauseRunning() &#123;</span><br><span class="line">        isRunning = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void resetExecutor() &#123;</span><br><span class="line">        isRunning = true;</span><br><span class="line">        taskQueue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clearExecutor() &#123;</span><br><span class="line">        pauseRunning();</span><br><span class="line">        taskQueue.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TaskEvent &#123;</span><br><span class="line">    private WeakReference&lt;ITask&gt; mTask;</span><br><span class="line">    int mEventType;</span><br><span class="line"></span><br><span class="line">    public ITask getTask() &#123;</span><br><span class="line">        return mTask.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTask(ITask mTask) &#123;</span><br><span class="line">        this.mTask = new WeakReference&lt;&gt;(mTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getEventType() &#123;</span><br><span class="line">        return mEventType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEventType(int mEventType) &#123;</span><br><span class="line">        this.mEventType = mEventType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class EventType &#123;</span><br><span class="line">        public static final int DO = 0X00;</span><br><span class="line">        public static final int FINISH = 0X01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了整个队列已经封装好了，下面看看如何使用吧：</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>定义一个Task，继承 BaseTask，并实现对应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class LogTask extends BaseTask &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public LogTask(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行任务方法，在这里实现你的任务具体内容</span><br><span class="line">    @Override</span><br><span class="line">    public void doTask() &#123;</span><br><span class="line">        super.doTask();</span><br><span class="line">        Log.i(&quot;LogTask&quot;, &quot;--doTask-&quot; + name);</span><br><span class="line">        </span><br><span class="line">        //如果这个Task的执行时间是不确定的，比如上传图片，那么在上传成功后需要手动调用</span><br><span class="line">        //unLockBlock方法解除阻塞，例如：</span><br><span class="line">        uploadImage(new UploadListener&#123;</span><br><span class="line">           void onSuccess()&#123;</span><br><span class="line">                unLockBlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //任务执行完的回调，在这里你可以做些释放资源或者埋点之类的操作</span><br><span class="line">    @Override</span><br><span class="line">    public void finishTask() &#123;</span><br><span class="line">        super.finishTask();</span><br><span class="line">        Log.i(&quot;LogTask&quot;, &quot;--finishTask-&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后依次入队使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn1).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        new LogTask(&quot;DEFAULT&quot;)</span><br><span class="line">                .setDuration(5000) //设置了时间，代表这个任务时间是确定的，如果不确定，则不用设置</span><br><span class="line">                .setPriority(TaskPriority.DEFAULT) //设置优先级，默认是DEFAULT</span><br><span class="line">                .enqueue(); //入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">findViewById(R.id.btn2).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        new LogTask(&quot;LOW&quot;)</span><br><span class="line">                .setDuration(4000)</span><br><span class="line">                .setPriority(TaskPriority.LOW)</span><br><span class="line">                .enqueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">findViewById(R.id.btn3).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        new LogTask(&quot;HIGH&quot;)</span><br><span class="line">                .setDuration(3000)</span><br><span class="line">                .setPriority(TaskPriority.HIGH)</span><br><span class="line">                .enqueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>就这样就可以了，是不是很简单，随便依次点击按钮多下，你会发现任务都在根据优先级排队执行了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/3/168135e3bcd7b164?w=2106&amp;h=658&amp;f=gif&amp;s=1372640" alt></p><p>获取当前运行任务的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogTask task = (LogTask) CurrentRunningTask.getCurrentShowingTask();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
